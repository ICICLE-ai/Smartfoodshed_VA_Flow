{"remainingRequest":"/Users/yameitu/Desktop/ICIRCLE/Smartfoodshed_VA_Flow/frontend/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/yameitu/Desktop/ICIRCLE/Smartfoodshed_VA_Flow/frontend/src/components/viewer/graphviewer/Inner.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/yameitu/Desktop/ICIRCLE/Smartfoodshed_VA_Flow/frontend/src/components/viewer/graphviewer/Inner.vue","mtime":1664764577333},{"path":"/Users/yameitu/Desktop/ICIRCLE/Smartfoodshed_VA_Flow/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1644041617264},{"path":"/Users/yameitu/Desktop/ICIRCLE/Smartfoodshed_VA_Flow/frontend/node_modules/@vue/cli-plugin-babel/node_modules/babel-loader/lib/index.js","mtime":1661441977623},{"path":"/Users/yameitu/Desktop/ICIRCLE/Smartfoodshed_VA_Flow/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1644041617264},{"path":"/Users/yameitu/Desktop/ICIRCLE/Smartfoodshed_VA_Flow/frontend/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1661441977645}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIE5lbzRqZDMgZnJvbSAnQC9qcy9OZW80akQzLmpzJwppbXBvcnQgKiBhcyBkM0xhc3NvIGZyb20gJ2QzLWxhc3NvJwppbXBvcnQgKiBhcyBkMyBmcm9tICdkMycKaW1wb3J0ICogYXMgS0d1dGlscyBmcm9tICdAL3V0aWxzL0tHdXRpbHMuanMnCmltcG9ydCB7bWFwU3RhdGV9IGZyb20gJ3Z1ZXgnCmltcG9ydCAqIGFzIGQzdGlwIGZyb20gJ0AvdXRpbHMvZDMtdGlwJwppbXBvcnQgR2xvYmFsdmlld01lbnVCYXIgZnJvbSAnQC9jb21wb25lbnRzL3V0aWxpdHkvR2xvYmFsVmlld1Rvb2wvR2xvYmFsdmlld01lbnVCYXInCmltcG9ydCB7CiAgY29tcG9uZW50RW5hYmxlRHJhZ0hhbmRsZXIsCiAgY29tcG9uZW50RGlzYWJsZURyYWdIYW5kbGVyLAp9IGZyb20gIkAvdXRpbHMvZ2xvYmFsVmlld0NhcmRVdGlscy90b29sSGVscGVyLmpzIjsKLy8gaW1wb3J0IE5vZGVSZWxPdmVydmlldyBmcm9tICdAL2NvbXBvbmVudHMvTm9kZVJlbE92ZXJ2aWV3JwpleHBvcnQgZGVmYXVsdHsKICBwcm9wczogWydpdGVtUHJvcHMnLCAnZml4ZWQnXSwgCiAgY29tcG9uZW50czogewogICAgR2xvYmFsdmlld01lbnVCYXIKICB9LCAgCiAgZGF0YSAoKSB7CiAgICByZXR1cm4gewogICAgICBzZWxlY3RlZEVudGl0aWVzOiBbXSwgCiAgICAgIHNlbGVjdGVkUmVsYXRpb25zOiBbXSwKICAgICAgY3VycmVudEVudGl0aWVzOiBbXSwgCiAgICAgIGN1cnJlbnRSZWxhdGlvbnM6IFtdLAogICAgICBsYXNzb0NvbG9yOiAiZ3JleSIsIAogICAgICB6b29tUGFuQ29sb3I6ICJncmVlbiIsIAogICAgICBsYXNzb1N0YXR1czogZmFsc2UsCiAgICAgIHpvb21QYW5TdGF0dXM6IGZhbHNlLCAKICAgICAgbGFzc286IG51bGwsIAogICAgICB6b29tOiBudWxsLCAKICAgICAgbG9hZGluZ192YWx1ZTpmYWxzZSwKICAgICAgdGlwOiBudWxsLAogICAgICB1c2VyX2RlZmluZWRfdGhyZTogNSwvLyB1c2VyIGRlZmluZWQgdGhyZXNob2xkIHRvIHNob3cgaG93IG1hbnkgbm9kZXMgd2Ugd2FudCB0byBzZWUgaWYgd2UgZXhwYW5kIG9uZSBub2RlIAogICAgICBuZW80amQzIDogbnVsbCwKICAgICAgYnJ1c2hlZDogeyJlbnRpdHlfdHlwZSI6IFtdLCAicmVsYXRpb25zaGlwX3R5cGUiOiBbXX0sCiAgICAgIHNob3dPdmVydmlldzpmYWxzZSwgCiAgICAgIHNob3dNYXhSZXRyaWV2ZTpmYWxzZSwKICAgICAgZmF2OiB0cnVlLAogICAgICBtZW51OiBmYWxzZSwKICAgICAgbWVzc2FnZTogZmFsc2UsCiAgICAgIGhpbnRzOiB0cnVlLAogICAgICBzZWxlY3RlZENvbG9yOiBudWxsLCAKICAgICAgc2hvd1Jlc1RocmU6IGZhbHNlLCAvLyByZXNpbGllbmNlIHRocmVzaG9sZCBiYXIgCiAgICAgIHJlc2lsaWVuY2VfdGhyZTogMCwgIC8vIHNlbGVjdGVkIHRocmVzaG9sZCBvZiByZXNpbGllbmNlIAogICAgICAvLyBtaW5fcmVzaWxpZW5jZTogMCwKICAgICAgbWF4X3Jlc2lsaWVuY2U6IDEsIC8vIG1heGltdW0gdmFsdWUgb2YgdGhlIHNjcm9sbCBiYXIgZm9yIHJlc2lsaWVuY2UgdGhyZXNob2xkIAogICAgICBGSVhFRDogZmFsc2UgCiAgICB9CiAgfSwKICBjcmVhdGVkICgpIHsKICAgIC8vIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdnZXRHcmFwaE92ZXJ2aWV3JykKICAgIC8vIHdpbmRvd1snZDMnXSA9IGQzCiAgICB0aGlzLnRpcCA9IGQzdGlwKCkKICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2QzLXRpcCcpCiAgICAgICAgICAgIC5vZmZzZXQoWy0xMCwgODBdKQogICAgICAgICAgICAuaHRtbChmdW5jdGlvbihkKSB7CiAgICAgICAgICAgICAgcmV0dXJuICI8c3Ryb25nPlJlbGF0aW9uOiA8L3N0cm9uZz4iICsgZCArICI8YnI+PC9zcGFuPiI7CiAgICB9KQogICAgY29uc29sZS5sb2coZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiI2Rpdl9ncmFwaCIpKTsKICAgIAogIH0sCiAgbWV0aG9kczogewogICAgZGJsQ2xpY2tIYW5kbGVyKCkgewogICAgICB0aGlzLnRvZ2dsZUZpeENvbXBQb3MoKTsKICAgIH0sIAoKICAgIHRvZ2dsZUZpeENvbXBQb3MoKSB7CiAgICAgIHRoaXMuRklYRUQgPSAhdGhpcy5GSVhFRDsKICAgICAgaWYgKCF0aGlzLmRhdGFTdGF0dXMpIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgaWYgKHRoaXMuRklYRUQpIHsKICAgICAgICBjb21wb25lbnREaXNhYmxlRHJhZ0hhbmRsZXIoCiAgICAgICAgICBgLmdsb2JhbHZpZXctY2FudmFzLSR7dGhpcy5pdGVtUHJvcHMuaWR9YCwKICAgICAgICAgIHRoaXMudG9vbFN0YXR1cwogICAgICAgICk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29tcG9uZW50RW5hYmxlRHJhZ0hhbmRsZXIoCiAgICAgICAgICBgLmdsb2JhbHZpZXctY2FudmFzLSR7dGhpcy5pdGVtUHJvcHMuaWR9YCwKICAgICAgICAgIHRoaXMudG9vbFN0YXR1cwogICAgICAgICk7CiAgICAgIH0KICAgIH0sCgoKICAgIHRvb2xFbmFibGVUb2dnbGVIYW5kbGVyKGUpIHsKICAgICAgYWxlcnQoZSkKICAgIH0sCiAgICBjaGFuZ2VUaHJlc2hvbGQoKXsKICAgICAgLy8gY2hhbmdlIHVzZXIgZGVmaW5lIHRocmVzaG9sZCBmb3IgaG93IG1hbnkgbm9kZXMgd2Ugd2FudCB0byBleHBhbmQgCiAgICAgIHRoaXMuJHN0b3JlLmRpc3BhdGNoKCdzZXRFeHBhbmRUaCcsIHRoaXMudXNlcl9kZWZpbmVkX3RocmUpCiAgICB9LAogICAgZHJhd05lbzRqZDMgKCkgewogICAgICB2YXIgdGhhdCA9IHRoaXMKICAgICAgZDMuc2VsZWN0QWxsKCIuZDMtdGlwIikucmVtb3ZlKCkKCgogICAgICBpZih0aGlzLm5lbzRqZDMgPT0gbnVsbCl7CiAgICAgICAgdmFyIG5lbzRqZDMgPSBOZW80amQzLmRlZmF1bHQoJyNkaXZfZ3JhcGgnLCB7CiAgICAgICAgICBuZW80akRhdGE6IHRoaXMuaXRlbVByb3BzLmdyYXBoRGF0YSwKICAgICAgICAgIG5vZGVSYWRpdXM6IDMwLAogICAgICAgICAgaW5mb1BhbmVsOiBmYWxzZSwKCiAgICAgICAgICBvbk5vZGVEb3VibGVDbGljazogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgICAgLy8gdGhhdC5kYmNsaWNrKG5vZGUpCiAgICAgICAgICB9LAogICAgICAgICAgb25Ob2RlTW91c2VFbnRlcjogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgICAgdGhhdC5ob3Zlcl9ub2RlID0gbm9kZQogICAgICAgICAgICBjb25zb2xlLmxvZygnaG92ZXJpbmcnLCBub2RlKQogICAgICAgICAgfSwKICAgICAgICAgIG9uTm9kZUNsaWNrOiBmdW5jdGlvbiAobm9kZSxpZHgpIHsKICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobm9kZSxpZCkKICAgICAgICAgICAgLy8gQ3JlYXRlIGR1bW15IGRhdGEKICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobm9kZSkKICAgICAgICAgICAgaWYgKG5vZGUuc2hvd0J0blBhbmVsID09IHRydWUpIHsKICAgICAgICAgICAgICBkMy5zZWxlY3QoYCNub2RlLSR7bm9kZS5pZH1gKS5zZWxlY3RBbGwoJy5jaXJjbGUtYnV0dG9uJykucmVtb3ZlKCkKICAgICAgICAgICAgICBub2RlLnNob3dCdG5QYW5lbCA9IGZhbHNlCiAgICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICAgIH0KICAgICAgICAgICAgbm9kZS5zaG93QnRuUGFuZWwgPSB0cnVlIAogICAgICAgICAgICB2YXIgZGF0YSA9IHsgYjoge2FjdGlvbjogInJlbW92ZSIsIHZhbHVlOiAxMCwgcG9zOjB9IH0gLy8gb25seSB0d28gb3BlcmF0aW9ucyAKCiAgICAgICAgICAgIGlmKHRoYXQuaXRlbVByb3BzLnJlbGF0aW9uU3RhdHVzUmVhZHk9PWZhbHNlKXsKICAgICAgICAgICAgICAvLyByZW5kZXIgdGhlIGxvYWRpbmcgcGFuZWwgCiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ25vbm9ub25vJykKICAgICAgICAgICAgICAvLwogICAgICAgICAgICB9ZWxzZXsKICAgICAgICAgICAgICBpZih0aGF0Lml0ZW1Qcm9wcy5yZWxhdGlvblN0YXR1c1JlYWR5PT0iZnJvbU1hcCIpewogICAgICAgICAgICAgIHZhciByZWxhdGlvbl9kYXRhID0gbm9kZVsncmVsYXRpb25zaGlwX3R5cGVzJ10KICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlewogICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoYXQucmVsYXRpb25UeXBlRGF0YVsncmVzdWx0cyddWzBdWydkYXRhJ11bMF1bJ2dyYXBoJ11bJ25vZGVzJ10pCiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coaWR4KQogICAgICAgICAgICAgIHZhciBmaWx0ZXJlZF9yZWxhdGlvbl90eXBlX2RhdGEgPSB0aGF0LnJlbGF0aW9uVHlwZURhdGFbJ3Jlc3VsdHMnXVswXVsnZGF0YSddWzBdWydncmFwaCddWydub2RlcyddLmZpbHRlcihkID0+IGQuaWQgPT0gbm9kZS5pZCkKICAgICAgICAgICAgICB2YXIgcmVsYXRpb25fZGF0YSA9IGZpbHRlcmVkX3JlbGF0aW9uX3R5cGVfZGF0YVswXVsncmVsYXRpb25zaGlwX3R5cGVzJ10KICAgICAgICAgICAgICAvLyBnZXQgdGhlIHN1bSBvZiBhbGwgcmVsIGNvdW50cyAKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBzdW1WYWx1ZXMgPSBvYmogPT4gT2JqZWN0LnZhbHVlcyhvYmopLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpOwogICAgICAgICAgICAgIGNvbnN0IHRvdGFsX2MgID0gc3VtVmFsdWVzKHJlbGF0aW9uX2RhdGEpCiAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIGRvdW50IGRhdGEKICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZWxhdGlvbl9kYXRhKSkgewogICAgICAgICAgICAgICAgZGF0YVtrZXldID0ge2FjdGlvbjoga2V5LCB2YWx1ZTogKHZhbHVlL3RvdGFsX2MpKjMwfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygiY2hlY2sgZGF0YSIpCiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZGF0YSkKICAgICAgICAgICAgfSAKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIHNvcnRpbmcgCiAgICAgICAgICAgIAogICAgICAgICAgICBsZXQgdGhpc19nID0gZDMuc2VsZWN0KGAjbm9kZS0ke25vZGUuaWR9YCkKCiAgICAgICAgICAgIC8vIGxldCBhcHBlbmRfZyA9IHRoaXNfZy5hcHBlbmQoJ2cnKS5hdHRyKCJ0cmFuc2Zvcm0iLCAidHJhbnNsYXRlKCIgKyBub2RlWyd4J10gKyAiLCIgKyBub2RlWyd5J10gKyAiKSIpOwogICAgICAgICAgICBsZXQgYXBwZW5kX2cgPSB0aGlzX2cKCiAgICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgcG9zaXRpb24gb2YgZWFjaCBncm91cCBvbiB0aGUgcGllOgogICAgICAgICAgICB2YXIgcGllID0gZDMucGllKCkKICAgICAgICAgICAgICAuc29ydChudWxsKSAvL2F2b2lkaW5nIHRvIHNvcnQgdGhlIHBpZSwgbWFrZSBzdXJlIHRoZSByZW1vdmUgYnV0dG9uIGluIHRoZSBzYW1lIHBvc2l0aW9uIAogICAgICAgICAgICAgIC52YWx1ZShmdW5jdGlvbihkKSB7cmV0dXJuIGQudmFsdWUudmFsdWU7IH0pCiAgICAgICAgICAgIHZhciBkYXRhX3JlYWR5ID0gcGllKGQzLmVudHJpZXMoZGF0YSkpCiAgICAgICAgICAgIAoKICAgICAgCiAgICAgICAgICAgICAgLy8gcmVtb3ZhbCAvIGV4cGFuZCBvcGVyYXRpb25zIAogICAgICAgICAgICB2YXIgb3BlcmF0aW9uX2J1dHRvbnNfZyA9IGFwcGVuZF9nLnNlbGVjdEFsbCgnd2hhdGV2ZXInKQogICAgICAgICAgICAgIC5kYXRhKGRhdGFfcmVhZHkpCiAgICAgICAgICAgICAgLmVudGVyKCkKICAgICAgICAgICAgCiAgICAgICAgICAgIHZhciBvcGVyYXRpb25fYnV0dG9ucyA9IG9wZXJhdGlvbl9idXR0b25zX2cuYXBwZW5kKCdwYXRoJykKICAgICAgICAgICAgICAuYXR0cignZCcsIGQzLmFyYygpCiAgICAgICAgICAgICAgICAuaW5uZXJSYWRpdXMoMzApICAgICAgICAgLy8gVGhpcyBpcyB0aGUgc2l6ZSBvZiB0aGUgZG9udXQgaG9sZQogICAgICAgICAgICAgICAgLm91dGVyUmFkaXVzKDUwKQogICAgICAgICAgICAgICkKICAgICAgICAgICAgICAuYXR0cigiY2xhc3MiLCAiY2lyY2xlLWJ1dHRvbiIpCiAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCBmdW5jdGlvbihkLGkpeyAKICAgICAgICAgICAgICAgIGlmKGk9PTApewogICAgICAgICAgICAgICAgICByZXR1cm4gIiNCQjY0NjQiCiAgICAgICAgICAgICAgICB9ZWxzZXsKICAgICAgICAgICAgICAgICAgcmV0dXJuICIjOTRCNDlGIgogICAgICAgICAgICAgICAgfSAKICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgIC8vIC5hdHRyKCJzdHJva2UiLCAiYmxhY2siKQogICAgICAgICAgICAgIC5zdHlsZSgic3Ryb2tlLXdpZHRoIiwgIjJweCIpCiAgICAgICAgICAgICAgLnN0eWxlKCJzdHJva2UiLCAid2hpdGUiKQogICAgICAgICAgICAgIC5zdHlsZSgib3BhY2l0eSIsIDAuNykKICAgICAgICAgICAgICAuc3R5bGUoJ2N1cnNvcicsJ3BvaW50ZXInKQogICAgICAgICAgICAgIC5hdHRyKCd0aXRsZScsJ3Rlc3QnKQoKICAgICAgICAgICAgdmFyIGhpZGVfaWNvbiA9IG9wZXJhdGlvbl9idXR0b25zX2cuYXBwZW5kKCdwYXRoJykgCiAgICAgICAgICAgICAgLmF0dHIoJ2QnLCAnTTEyLDIwQzcuNTksMjAgNCwxNi40MSA0LDEyQzQsNy41OSA3LjU5LDQgMTIsNEMxNi40MSw0IDIwLDcuNTkgMjAsMTJDMjAsMTYuNDEgMTYuNDEsMjAgMTIsMjBNMTIsMkExMCwxMCAwIDAsMCAyLDEyQTEwLDEwIDAgMCwwIDEyLDIyQTEwLDEwIDAgMCwwIDIyLDEyQTEwLDEwIDAgMCwwIDEyLDJNNywxM0gxN1YxMUg3JykKICAgICAgICAgICAgICAuYXR0cigidHJhbnNmb3JtIiwgJ3RyYW5zbGF0ZSgyMCwgLTM1KSBzY2FsZSgwLjcpJykKICAgICAgICAgICAgICAuYXR0cigiY2xhc3MiLCAiY2lyY2xlLWJ1dHRvbiIpCiAgICAgICAgICAgIAogICAgICAgICAgICAKCiAgICAgICAgICAgIGQzLnNlbGVjdCgnc3ZnJykuY2FsbCh0aGF0LnRpcCkKICAgICAgICAgICAgICAvLyBob3ZlcmluZyBlZmZlY3QgCiAgICAgICAgICAgIG9wZXJhdGlvbl9idXR0b25zLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbihwKXsKICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsMSkKICAgICAgICAgICAgICAgIGxldCByZWwgPSBwWydkYXRhJ11bJ3ZhbHVlJ11bJ2FjdGlvbiddCiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZWwpCiAgICAgICAgICAgICAgICB0aGF0LnRpcC5zaG93KHJlbCk7CiAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JyxmdW5jdGlvbihwKXsKICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsMC43KQogICAgICAgICAgICAgICAgbGV0IHJlbCA9IHBbJ2RhdGEnXVsndmFsdWUnXVsnYWN0aW9uJ10KICAgICAgICAgICAgICAgIHRoYXQudGlwLmhpZGUocmVsKTsKICAgICAgICAgICAgICB9KQogICAgICAgICAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbihkLGkpewogICAgICAgICAgICAgICAgbGV0IGNsaWNrZWRfbm9kZV9pZCA9IG5vZGVbJ2lkJ10KICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGQuZGF0YS52YWx1ZS5hY3Rpb24gCiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhkKQogICAgICAgICAgICAgICAgdGhhdC50aXAuaGlkZShkLmRhdGEudmFsdWUuYWN0aW9uKQogICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSAicmVtb3ZlIil7CiAgICAgICAgICAgICAgICAgIC8vIHRpcC5oaWRlKGQuZGF0YS52YWx1ZS5hY3Rpb24pCiAgICAgICAgICAgICAgICAgIHRoYXQuJHN0b3JlLmRpc3BhdGNoKCJub2RlX3JlbW92ZSIsIHtub2RlX2lkOiBjbGlja2VkX25vZGVfaWR9KQogICAgICAgICAgICAgICAgfWVsc2UgewogICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZC5kYXRhLnZhbHVlLmFjdGlvbikKICAgICAgICAgICAgICAgICAgdGhhdC4kc3RvcmUuZGlzcGF0Y2goIm5vZGVfZXhwYW5kIiwge25vZGVfaWQ6IGNsaWNrZWRfbm9kZV9pZCwgcmVsYXRpb246IGQuZGF0YS5rZXl9KQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0pCiAgICAgICAgICB9CiAgICAgIH0pCiAgICAgICAgdGhpcy5uZW80amQzID0gbmVvNGpkMwogICAgICB9ZWxzZXsKICAgICAgICB0aGlzLm5lbzRqZDMudXBkYXRlV2l0aE5lbzRqRGF0YSh0aGlzLml0ZW1Qcm9wcy5ncmFwaERhdGEpCiAgICAgIH0KICAgICAgaWYgKHRoYXQubGFzc29TdGF0dXMpIHsKICAgICAgICB0aGF0LmRpc2FibGVab29tKCkKICAgICAgICB0aGF0LmVuYWJsZUxhc3NvKCkKICAgICAgfSAKICAgICAgCiAgICAgIGlmICh0aGF0Lnpvb21QYW5TdGF0dXMpIHsKICAgICAgICB0aGF0LmRpc2FibGVMYXNzbygpIAogICAgICAgIHRoYXQuZW5hYmxlWm9vbVBhbigpCiAgICAgIH0KICAgICAgLy8gdGhhdC5lbmFibGVMYXNzbygpCiAgICAgIAogICAgfSwKICAgIHJlc2V0R3JhcGhUYWJsZUhhbmRsZXIoKXsKICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goInJlc2V0VGFibGVHcmFwaCIpCiAgICB9LAogICAgdG9nZ2xlWm9vbVBhbkxhc3NvKCl7CiAgICAgIHRoaXMuem9vbVBhblN0YXR1cyA9ICF0aGlzLnpvb21QYW5TdGF0dXMgCiAgICAgIHRoaXMubGFzc29TdGF0dXMgPSAhdGhpcy5sYXNzb1N0YXR1cwogICAgICB0aGlzLnpvb21QYW5Db2xvciA9IHRoaXMuem9vbVBhblN0YXR1cz8iZ3JlZW4iOiJncmV5IgogICAgICB0aGlzLmxhc3NvQ29sb3IgPSB0aGlzLmxhc3NvU3RhdHVzPyJncmVlbiI6ImdyZXkiCiAgICB9LCAKICAgIHpvb21QYW5Ub2dnbGVIYW5kbGVyKCkgewogICAgICBpZiAoIXRoaXMuem9vbVBhblN0YXR1cykgewogICAgICAgIHRoaXMudG9nZ2xlWm9vbVBhbkxhc3NvKCkgCiAgICAgICAgdGhpcy5kaXNhYmxlTGFzc28oKQogICAgICAgIHRoaXMuZW5hYmxlWm9vbVBhbigpCiAgICAgIH0KICAgIH0sIAogICAgbGFzc29Ub2dnbGVIYW5kbGVyKCl7CiAgICAgIGlmICghdGhpcy5sYXNzb1N0YXR1cykgewogICAgICAgIHRoaXMudG9nZ2xlWm9vbVBhbkxhc3NvKCkKICAgICAgICB0aGlzLmRpc2FibGVab29tKCkKICAgICAgICB0aGlzLmVuYWJsZUxhc3NvKCkKICAgICAgICAvLyB0aGlzLmVuYWJsZVpvb21QYW4oKQogICAgICB9CiAgICAgIAogICAgfSwKICAgIGVuYWJsZUxhc3NvKCl7CiAgICAgIGNvbnN0IHN2ZyA9IGQzLnNlbGVjdCgnI2Rpdl9ncmFwaCcpLnNlbGVjdCgic3ZnIikKICAgICAgdmFyIGNpcmNsZXNfcXVlc3Rpb24gPSBzdmcuc2VsZWN0QWxsKCcub3V0bGluZScpCiAgICAgIGxldCB0aGF0ID0gdGhpcwogICAgICB2YXIgbGFzc29fc3RhcnQgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgY29uc29sZS5sb2coMTExKQogICAgICAgIGxhc3NvLml0ZW1zKCkKICAgICAgICAgIC5hdHRyKCdmaWxsJywgImdyZWVuIikKICAgICAgICAgIC5jbGFzc2VkKCdub3RfcG9zc2libGUnLCB0cnVlKQogICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgZmFsc2UpCiAgICAgIH0KICAgICAgdmFyIGxhc3NvX2RyYXcgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgLy8gU3R5bGUgdGhlIHBvc3NpYmxlIGRvdHMKICAgICAgICBsYXNzby5wb3NzaWJsZUl0ZW1zKCkKICAgICAgICAgIC5jbGFzc2VkKCdub3RfcG9zc2libGUnLCBmYWxzZSkKICAgICAgICAgIC5jbGFzc2VkKCdwb3NzaWJsZScsIHRydWUpCgogICAgICAgIC8vIFN0eWxlIHRoZSBub3QgcG9zc2libGUgZG90CiAgICAgICAgbGFzc28ubm90UG9zc2libGVJdGVtcygpCiAgICAgICAgICAuY2xhc3NlZCgnbm90X3Bvc3NpYmxlJywgdHJ1ZSkKICAgICAgICAgIC5jbGFzc2VkKCdwb3NzaWJsZScsIGZhbHNlKQogICAgICB9CiAgICAgIHZhciBsYXNzb19lbmQgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgbGFzc28uaXRlbXMoKQogICAgICAgICAgLmNsYXNzZWQoJ25vdF9wb3NzaWJsZScsIGZhbHNlKQogICAgICAgICAgLmNsYXNzZWQoJ3Bvc3NpYmxlJywgZmFsc2UpCgogICAgICAgIGxhc3NvLnNlbGVjdGVkSXRlbXMoKQogICAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgdHJ1ZSkKICAgICAgICB0aGF0LnNlbGVjdGVkRW50aXRpZXMuc3BsaWNlKDAsIHRoYXQuc2VsZWN0ZWRFbnRpdGllcy5sZW5ndGgpCiAgICAgICAgdGhhdC5zZWxlY3RlZFJlbGF0aW9ucy5zcGxpY2UoMCwgdGhhdC5zZWxlY3RlZFJlbGF0aW9ucy5sZW5ndGgpIAogICAgICAgIGxhc3NvLnNlbGVjdGVkSXRlbXMoKS5lYWNoKGZ1bmN0aW9uKGQpewogICAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLm5vZGVOYW1lIAogICAgICAgICAgCiAgICAgICAgICBpZiAobGFiZWwgPT0gImNpcmNsZSIpIHsKICAgICAgICAgICAgY29uc29sZS5sb2coImFkZGluZyBlbnRpdHkiICsgZC5pZCkKICAgICAgICAgICAgdGhhdC5zZWxlY3RlZEVudGl0aWVzLnB1c2goZC5pZCkKICAgICAgICAgIH1lbHNlIHsKICAgICAgICAgICAgY29uc29sZS5sb2coImFkZGluZyBSZWxhdGlvbnMiICsgZC5pZCkKICAgICAgICAgICAgdGhhdC5zZWxlY3RlZFJlbGF0aW9ucy5wdXNoKGQuaWQpCiAgICAgICAgICB9CiAgICAgICAgICAKICAgICAgICB9KQogICAgICAgIC8vIFJlc2V0IHRoZSBzdHlsZSBvZiB0aGUgbm90IHNlbGVjdGVkIGRvdHMKICAgICAgICAvLyBsYXNzby5ub3RTZWxlY3RlZEl0ZW1zKCkKICAgICAgICAKICAgICAgfQogICAgICB2YXIgbGFzc28gPSBkM0xhc3NvLmxhc3NvKCkKICAgICAgICAuY2xvc2VQYXRoU2VsZWN0KHRydWUpCiAgICAgICAgLmNsb3NlUGF0aERpc3RhbmNlKDEwMCkKICAgICAgICAuaXRlbXMoY2lyY2xlc19xdWVzdGlvbikKICAgICAgICAudGFyZ2V0QXJlYShzdmcpCiAgICAgICAgLm9uKCdzdGFydCcsIGxhc3NvX3N0YXJ0KQogICAgICAgIC5vbignZHJhdycsIGxhc3NvX2RyYXcpCiAgICAgICAgLm9uKCdlbmQnLCBsYXNzb19lbmQpCgogICAgICBzdmcuY2FsbChsYXNzbykKICAgIH0sIAogICAgZGlzYWJsZUxhc3NvKCkgewogICAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3QoJyNkaXZfZ3JhcGgnKS5zZWxlY3QoInN2ZyIpIAogICAgICBzdmcub24oIi5kcmFnc3RhcnQiLCBudWxsKTsKICAgICAgc3ZnLm9uKCIuZHJhZyIsIG51bGwpOwogICAgICBzdmcub24oIi5kcmFnZW5kIiwgbnVsbCk7CiAgICB9LCAKICAgIGVuYWJsZVpvb21QYW4oKXsKICAgICAgY29uc3Qgc3ZnID0gZDMuc2VsZWN0KCcjZGl2X2dyYXBoJykuc2VsZWN0KCJzdmciKSAKICAgICAgc3ZnLmNhbGwoZDMuem9vbSgpLm9uKCd6b29tJywgZnVuY3Rpb24gKCkgewogICAgICAgIHZhciBzY2FsZSA9IGQzLmV2ZW50LnRyYW5zZm9ybS5rLAogICAgICAgICAgdHJhbnNsYXRlID0gW2QzLmV2ZW50LnRyYW5zZm9ybS54LCBkMy5ldmVudC50cmFuc2Zvcm0ueV0KICAgICAgICBjb25zb2xlLmxvZygxKQogICAgICAgIGNvbnN0IGcgPSBzdmcuc2VsZWN0KCJnIikKICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHRyYW5zbGF0ZVswXSArICcsICcgKyB0cmFuc2xhdGVbMV0gKyAnKSBzY2FsZSgnICsgc2NhbGUgKyAnKScpCiAgICAgIH0pKQogICAgICAub24oJ2RibGNsaWNrLnpvb20nLCBudWxsKQogICAgfSwKICAgIGRpc2FibGVab29tKCkgewogICAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3QoJyNkaXZfZ3JhcGgnKS5zZWxlY3QoInN2ZyIpIAogICAgICBzdmcub24oJy56b29tJywgbnVsbCkKICAgIH0sCiAgICB0b2dnbGVPdmVydmlld1BhbmVsKGZvY3VzKXsKICAgICAgaWYgKGZvY3VzID09ICJlbnRpdHkiKSB7CiAgICAgICAgY29uc3QgY29udGFpbmVyRm9jdXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCIjZGl2X25vZGVfb3ZlcnZpZXciKQogICAgICAgIGNvbnN0IGNvbnRhaW5lclVuRm9jdXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCIjZGl2X2xpbmtfb3ZlcnZpZXciKQogICAgICAgIGNvbnRhaW5lckZvY3VzLnN0eWxlLmJvcmRlciA9ICIycHggc29saWQgZ3JlZW4iCiAgICAgICAgY29udGFpbmVyVW5Gb2N1cy5zdHlsZS5ib3JkZXIgPSAiTm9uZSIKICAgICAgfSBlbHNlewogICAgICAgIGNvbnN0IGNvbnRhaW5lckZvY3VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiI2Rpdl9saW5rX292ZXJ2aWV3IikKICAgICAgICBjb25zdCBjb250YWluZXJVbkZvY3VzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigiI2Rpdl9ub2RlX292ZXJ2aWV3IikKICAgICAgICBjb250YWluZXJGb2N1cy5zdHlsZS5ib3JkZXIgPSAiMnB4IHNvbGlkIGdyZWVuIgogICAgICAgIGNvbnRhaW5lclVuRm9jdXMuc3R5bGUuYm9yZGVyID0gIk5vbmUiCiAgICAgIH0KICAgIH0sCiAgICByZXRyaWV2ZV90eXBlc19ub2RlcygpewogICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgicmV0cmlldmVOb2Rlc0xpbmtzV2l0aFR5cGVzIiwgdGhpcy5icnVzaGVkKQogICAgfSwKICAgIC8vIGNpcmNsZVVwZGF0ZU1hdGNoQ29sb3IoKXsKICAgIC8vICAgaWYgKHRoaXMuY29sb3JNYXBwaW5nKSB7CiAgICAvLyAgICAgT2JqZWN0LmtleXModGhpcy5jb2xvck1hcHBpbmcpLmZvckVhY2goY2F0ZWdvcnkgPT4gewogICAgLy8gICAgICAgZDMuc2VsZWN0QWxsKCcuJytjYXRlZ29yeSkuc3R5bGUoJ2ZpbGwnLCB0aGlzLmNvbG9yTWFwcGluZ1tjYXRlZ29yeV0pCiAgICAvLyAgICAgfSkKICAgIC8vICAgfQogICAgLy8gfSwKICAgIHJlY29sb3JOb2RlKCl7CiAgICAgIHZhciB0aGF0ID0gdGhpcwogICAgICBkMy5zZWxlY3QoJyNkaXZfZ3JhcGgnKS5zZWxlY3RBbGwoJ2NpcmNsZScpLnN0eWxlKCdmaWxsJyxmdW5jdGlvbihkKXsKICAgICAgLy8gY2hlY2sgY29sZCBjaGFpbiBkYXRhCiAgICAgICAgaWYoJ3Jlc2lsaWVuY2UnIGluIGRbJ3Byb3BlcnRpZXMnXSl7CiAgICAgICAgICBjb25zb2xlLmxvZyhkWydwcm9wZXJ0aWVzJ10pCiAgICAgICAgICBpZihkWydwcm9wZXJ0aWVzJ11bJ3Jlc2lsaWVuY2UnXT49dGhhdC5yZXNpbGllbmNlX3RocmUpewogICAgICAgICAgICBpZih0aGF0LnNlbGVjdGVkQ29sb3IpewogICAgICAgICAgICAgIHJldHVybiB0aGF0LnNlbGVjdGVkQ29sb3IuaGV4CiAgICAgICAgICAgIH1lbHNlewogICAgICAgICAgICAgIHJldHVybiAiIzc4YjNkMCIKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgIH1lbHNlewogICAgICAgICAgICByZXR1cm4gIiNiM2IzYjMiCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9KQogICAgfQogIH0sCiAgd2F0Y2g6IHsKICAgIGZpeGVkKCkgewogICAgICBpZiAodGhpcy5maXhlZCkgewogICAgICAgIC8vIGNvbXBvbmVudERpc2FibGVEcmFnSGFuZGxlcigKICAgICAgICAvLyAgIGAuZ2xvYmFsdmlldy1jYW52YXMtJHt0aGlzLml0ZW1Qcm9wcy5pZH1gLAogICAgICAgIC8vICAgdGhpcy50b29sU3RhdHVzCiAgICAgICAgLy8gKTsKICAgICAgICB0aGlzLmVuYWJsZVpvb21QYW4oKQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMuZGlzYWJsZVpvb20oKQogICAgICB9CiAgICB9LAogICAgc2VsZWN0ZWRDb2xvcigpIHsKICAgICAgdGhpcy5yZWNvbG9yTm9kZSgpCiAgICAgIC8vIGQzLnNlbGVjdEFsbCgnY2lyY2xlJykuc3R5bGUoJ2ZpbGwnLCB0aGlzLnNlbGVjdGVkQ29sb3IuaGV4KQogICAgfSwKICAgIHJlc2lsaWVuY2VfdGhyZSgpewogICAgICB0aGlzLnJlY29sb3JOb2RlKCkKICAgIH0sCiAgICAnaXRlbVByb3BzLmdyYXBoRGF0YScoKSB7CiAgICAgIHZhciBhbGxfcmVzaWxpZW5jZSA9IFtdCiAgICAgIHRoaXMuaXRlbVByb3BzLmdyYXBoRGF0YVsncmVzdWx0cyddWzBdWydkYXRhJ11bMF1bJ2dyYXBoJ11bJ25vZGVzJ10uZm9yRWFjaChmdW5jdGlvbiAoZCkgewogICAgICAgIGRbJ3N0YXR1cyddID0gJ3VuY2xpY2tlZCcKICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIGNvbGQgY2hhaW4gZGF0YSBvciBub3QgCiAgICAgICAgaWYoInJlc2lsaWVuY2UiIGluIGRbJ3Byb3BlcnRpZXMnXSl7CiAgICAgICAgICBhbGxfcmVzaWxpZW5jZS5wdXNoKHBhcnNlRmxvYXQoZFsncHJvcGVydGllcyddWydyZXNpbGllbmNlJ10pKQogICAgICAgIH0KICAgICAgICAKICAgICAgfSkKICAgICAgLy8gdGhpcy5taW5fcmVzaWxpZW5jZSA9IGQzLm1pbihhbGxfcmVzaWxpZW5jZSkKICAgICAgdGhpcy5tYXhfcmVzaWxpZW5jZSA9IGQzLm1heChhbGxfcmVzaWxpZW5jZSkKICAgICAgY29uc29sZS5sb2codGhpcy5tYXhfcmVzaWxpZW5jZSkKICAgICAgLy9pbml0YWwgdGhlIHNlbGVjdGVkIHJlc2lsaWVuY2UKICAgICAgS0d1dGlscy5ncmFwaERhdGFQYXJzaW5nKHRoaXMuaXRlbVByb3BzLmdyYXBoRGF0YSwgdGhpcy5jdXJyZW50RW50aXRpZXMsIHRoaXMuY3VycmVudFJlbGF0aW9ucykKICAgICAgdGhpcy5kcmF3TmVvNGpkMygpCiAgICAgIC8vIHRoaXMuY2lyY2xlVXBkYXRlTWF0Y2hDb2xvcigpCiAgICB9LCAKICAgIHNlbGVjdGVkRW50aXRpZXModmFsKSB7CiAgICAgIGlmICh2YWwubGVuZ3RoID4gMCkgewogICAgICAgIGNvbnNvbGUubG9nKCJyZXRyaWV2aW5nIGRhdGEgbm93ISEhIikKICAgICAgICBjb25zb2xlLmxvZyh2YWwubGVuZ3RoKQogICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc2VsZWN0ZWRFbnRpdGllcykKICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnNlbGVjdGVkUmVsYXRpb25zKQogICAgICAgIGNvbnNvbGUubG9nKCIqKioqKioqKioqKioqKioqIikKICAgICAgICBjb25zb2xlLmxvZyh2YWwpCiAgICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goInJldHJpZXZlU3ViVGFibGUiLCB7ZW50aXRpZXM6IHRoaXMuc2VsZWN0ZWRFbnRpdGllcywgcmVsYXRpb25zOiB0aGlzLnNlbGVjdGVkUmVsYXRpb25zfSkKICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgicmV0cmlldmVOb2RlR2VvIiwge25vZGU6IHRoaXMuc2VsZWN0ZWRFbnRpdGllc30pCiAgICAgIH0KICAgIH0sIAogICAgc2VsZWN0ZWRSZWxhdGlvbnModmFsKXsKICAgICAgaWYgKHZhbC5sZW5ndGggPiAwKSB7CiAgICAgICAgY29uc29sZS5sb2coIioqKioqKioqKioqKioqKioiKQogICAgICAgIGNvbnNvbGUubG9nKHZhbC5sZW5ndGgpCiAgICAgICAgY29uc29sZS5sb2codmFsKSAKICAgICAgICBjb25zb2xlLmxvZygicmV0cmlldmluZyBkYXRhIG5vdyEhISIpCiAgICAgICAgY29uc29sZS5sb2codGhpcy5zZWxlY3RlZEVudGl0aWVzKQogICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc2VsZWN0ZWRSZWxhdGlvbnMpCiAgICAgICAgdGhpcy4kc3RvcmUuZGlzcGF0Y2goInJldHJpZXZlU3ViVGFibGUiLCB7ZW50aXRpZXM6IHRoaXMuc2VsZWN0ZWRFbnRpdGllcywgcmVsYXRpb25zOiB0aGlzLnNlbGVjdGVkUmVsYXRpb25zfSkKICAgICAgfQogICAgfSwgCiAgICBicnVzaGVkOnsKICAgICAgaGFuZGxlcih2YWwpewogICAgICAgICAgY29uc29sZS5sb2codmFsKTsKICAgICAgfSwKICAgICAgZGVlcDp0cnVlIAogICAgfSwKICAgICdpdGVtUHJvcHMucmVsYXRpb25TdGF0dXNSZWFkeSc6IGZ1bmN0aW9uICh2YWwpewogICAgICBjb25zb2xlLmxvZygicmVsYXRpb24gc3RhdHVzOiAiICsgdmFsKSAKICAgIH0sCiAgICAnaXRlbVByb3BzLnJlbGF0aW9uVHlwZURhdGEnOmZ1bmN0aW9uKHZhbCkgewogICAgICBpZih0aGlzLml0ZW1Qcm9wcy5yZWxhdGlvblN0YXR1c1JlYWR5KSB7CiAgICAgICAgY29uc29sZS5sb2coInJlbGF0aW9uIHR5cGUgZGF0YSBpcyByZWFkeSIpCgogICAgICB9ZWxzZXsKICAgICAgICBjb25zb2xlLmxvZygicmVsYXRpb24gdHlwZSBkYXRhIGlzIG5vdCByZWFkeSB5ZXQhIikKICAgICAgfQogICAgfSwKICAgICdpdGVtUHJvcHMubG9hZGluZyc6IGZ1bmN0aW9uKHZhbCl7CiAgICAgIHRoaXMubG9hZGluZ192YWx1ZSA9IHZhbAogICAgfSwKICAgIAogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIGdldEJvcmRlcigpIHsKICAgICAgcmV0dXJuIHRoaXMuRklYRUQgPyAiMnB4IHNvbGlkIGdyZXkiIDogIk5vbmUiOwogICAgfSwKICAgIC8vIEhFSUdIVCAoKSB7CiAgICAvLyAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQqMC43ICsgJ3B4JwogICAgLy8gfSwKICAgIC8vIE9WRVJWSUVXX0hFSUdIVCgpewogICAgLy8gICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0KjAuMyArICdweCcKICAgIC8vIH0KICB9Cn0K"},{"version":3,"sources":["Inner.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Inner.vue","sourceRoot":"src/components/viewer/graphviewer","sourcesContent":["<template>\n    <div class=\"card-inner\" :style=\"{border: getBorder}\">\n        <div\n          class=\"graph-btn-container\"\n        >\n        <GlobalviewMenuBar\n          @toolEnableToggle=\"toolEnableToggleHandler\"\n        />\n        </div>\n        <div id=\"div_graph\" class=\"fullHeight\" :style=\"{'height': '100%'}\"></div>   \n        <v-overlay :value=\"loading_value\">\n        <v-progress-circular\n          indeterminate\n          size=\"64\"\n        ></v-progress-circular>\n      </v-overlay>\n    </div>\n</template>\n\n<script>\nimport * as Neo4jd3 from '@/js/Neo4jD3.js'\nimport * as d3Lasso from 'd3-lasso'\nimport * as d3 from 'd3'\nimport * as KGutils from '@/utils/KGutils.js'\nimport {mapState} from 'vuex'\nimport * as d3tip from '@/utils/d3-tip'\nimport GlobalviewMenuBar from '@/components/utility/GlobalViewTool/GlobalviewMenuBar'\nimport {\n  componentEnableDragHandler,\n  componentDisableDragHandler,\n} from \"@/utils/globalViewCardUtils/toolHelper.js\";\n// import NodeRelOverview from '@/components/NodeRelOverview'\nexport default{\n  props: ['itemProps', 'fixed'], \n  components: {\n    GlobalviewMenuBar\n  },  \n  data () {\n    return {\n      selectedEntities: [], \n      selectedRelations: [],\n      currentEntities: [], \n      currentRelations: [],\n      lassoColor: \"grey\", \n      zoomPanColor: \"green\", \n      lassoStatus: false,\n      zoomPanStatus: false, \n      lasso: null, \n      zoom: null, \n      loading_value:false,\n      tip: null,\n      user_defined_thre: 5,// user defined threshold to show how many nodes we want to see if we expand one node \n      neo4jd3 : null,\n      brushed: {\"entity_type\": [], \"relationship_type\": []},\n      showOverview:false, \n      showMaxRetrieve:false,\n      fav: true,\n      menu: false,\n      message: false,\n      hints: true,\n      selectedColor: null, \n      showResThre: false, // resilience threshold bar \n      resilience_thre: 0,  // selected threshold of resilience \n      // min_resilience: 0,\n      max_resilience: 1, // maximum value of the scroll bar for resilience threshold \n      FIXED: false \n    }\n  },\n  created () {\n    // this.$store.dispatch('getGraphOverview')\n    // window['d3'] = d3\n    this.tip = d3tip()\n            .attr('class', 'd3-tip')\n            .offset([-10, 80])\n            .html(function(d) {\n              return \"<strong>Relation: </strong>\" + d + \"<br></span>\";\n    })\n    console.log(document.querySelector(\"#div_graph\"));\n    \n  },\n  methods: {\n    dblClickHandler() {\n      this.toggleFixCompPos();\n    }, \n\n    toggleFixCompPos() {\n      this.FIXED = !this.FIXED;\n      if (!this.dataStatus) {\n        return;\n      }\n      if (this.FIXED) {\n        componentDisableDragHandler(\n          `.globalview-canvas-${this.itemProps.id}`,\n          this.toolStatus\n        );\n      } else {\n        componentEnableDragHandler(\n          `.globalview-canvas-${this.itemProps.id}`,\n          this.toolStatus\n        );\n      }\n    },\n\n\n    toolEnableToggleHandler(e) {\n      alert(e)\n    },\n    changeThreshold(){\n      // change user define threshold for how many nodes we want to expand \n      this.$store.dispatch('setExpandTh', this.user_defined_thre)\n    },\n    drawNeo4jd3 () {\n      var that = this\n      d3.selectAll(\".d3-tip\").remove()\n\n\n      if(this.neo4jd3 == null){\n        var neo4jd3 = Neo4jd3.default('#div_graph', {\n          neo4jData: this.itemProps.graphData,\n          nodeRadius: 30,\n          infoPanel: false,\n\n          onNodeDoubleClick: function (node) {\n            // that.dbclick(node)\n          },\n          onNodeMouseEnter: function (node) {\n            that.hover_node = node\n            console.log('hovering', node)\n          },\n          onNodeClick: function (node,idx) {\n            // console.log(node,id)\n            // Create dummy data\n            // console.log(node)\n            if (node.showBtnPanel == true) {\n              d3.select(`#node-${node.id}`).selectAll('.circle-button').remove()\n              node.showBtnPanel = false\n              return\n            }\n            node.showBtnPanel = true \n            var data = { b: {action: \"remove\", value: 10, pos:0} } // only two operations \n\n            if(that.itemProps.relationStatusReady==false){\n              // render the loading panel \n              console.log('nononono')\n              //\n            }else{\n              if(that.itemProps.relationStatusReady==\"fromMap\"){\n              var relation_data = node['relationship_types']\n            }\n            else{\n              // console.log(that.relationTypeData['results'][0]['data'][0]['graph']['nodes'])\n              // console.log(idx)\n              var filtered_relation_type_data = that.relationTypeData['results'][0]['data'][0]['graph']['nodes'].filter(d => d.id == node.id)\n              var relation_data = filtered_relation_type_data[0]['relationship_types']\n              // get the sum of all rel counts \n            }\n            const sumValues = obj => Object.values(obj).reduce((a, b) => a + b);\n              const total_c  = sumValues(relation_data)\n              // generate the dount data\n              for (const [key, value] of Object.entries(relation_data)) {\n                data[key] = {action: key, value: (value/total_c)*30}\n              }\n              // console.log(\"check data\")\n              // console.log(data)\n            } \n            \n            // sorting \n            \n            let this_g = d3.select(`#node-${node.id}`)\n\n            // let append_g = this_g.append('g').attr(\"transform\", \"translate(\" + node['x'] + \",\" + node['y'] + \")\");\n            let append_g = this_g\n\n              // Compute the position of each group on the pie:\n            var pie = d3.pie()\n              .sort(null) //avoiding to sort the pie, make sure the remove button in the same position \n              .value(function(d) {return d.value.value; })\n            var data_ready = pie(d3.entries(data))\n            \n\n      \n              // removal / expand operations \n            var operation_buttons_g = append_g.selectAll('whatever')\n              .data(data_ready)\n              .enter()\n            \n            var operation_buttons = operation_buttons_g.append('path')\n              .attr('d', d3.arc()\n                .innerRadius(30)         // This is the size of the donut hole\n                .outerRadius(50)\n              )\n              .attr(\"class\", \"circle-button\")\n              .attr('fill', function(d,i){ \n                if(i==0){\n                  return \"#BB6464\"\n                }else{\n                  return \"#94B49F\"\n                } \n              })\n              // .attr(\"stroke\", \"black\")\n              .style(\"stroke-width\", \"2px\")\n              .style(\"stroke\", \"white\")\n              .style(\"opacity\", 0.7)\n              .style('cursor','pointer')\n              .attr('title','test')\n\n            var hide_icon = operation_buttons_g.append('path') \n              .attr('d', 'M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M7,13H17V11H7')\n              .attr(\"transform\", 'translate(20, -35) scale(0.7)')\n              .attr(\"class\", \"circle-button\")\n            \n            \n\n            d3.select('svg').call(that.tip)\n              // hovering effect \n            operation_buttons.on('mouseover', function(p){\n                d3.select(this).style('opacity',1)\n                let rel = p['data']['value']['action']\n                console.log(rel)\n                that.tip.show(rel);\n              })\n              .on('mouseout',function(p){\n                d3.select(this).style('opacity',0.7)\n                let rel = p['data']['value']['action']\n                that.tip.hide(rel);\n              })\n              .on('click', function(d,i){\n                let clicked_node_id = node['id']\n                const action = d.data.value.action \n                // console.log(d)\n                that.tip.hide(d.data.value.action)\n                if (action == \"remove\"){\n                  // tip.hide(d.data.value.action)\n                  that.$store.dispatch(\"node_remove\", {node_id: clicked_node_id})\n                }else {\n                  \n                  // console.log(d.data.value.action)\n                  that.$store.dispatch(\"node_expand\", {node_id: clicked_node_id, relation: d.data.key})\n                }\n              })\n          }\n      })\n        this.neo4jd3 = neo4jd3\n      }else{\n        this.neo4jd3.updateWithNeo4jData(this.itemProps.graphData)\n      }\n      if (that.lassoStatus) {\n        that.disableZoom()\n        that.enableLasso()\n      } \n      \n      if (that.zoomPanStatus) {\n        that.disableLasso() \n        that.enableZoomPan()\n      }\n      // that.enableLasso()\n      \n    },\n    resetGraphTableHandler(){\n      this.$store.dispatch(\"resetTableGraph\")\n    },\n    toggleZoomPanLasso(){\n      this.zoomPanStatus = !this.zoomPanStatus \n      this.lassoStatus = !this.lassoStatus\n      this.zoomPanColor = this.zoomPanStatus?\"green\":\"grey\"\n      this.lassoColor = this.lassoStatus?\"green\":\"grey\"\n    }, \n    zoomPanToggleHandler() {\n      if (!this.zoomPanStatus) {\n        this.toggleZoomPanLasso() \n        this.disableLasso()\n        this.enableZoomPan()\n      }\n    }, \n    lassoToggleHandler(){\n      if (!this.lassoStatus) {\n        this.toggleZoomPanLasso()\n        this.disableZoom()\n        this.enableLasso()\n        // this.enableZoomPan()\n      }\n      \n    },\n    enableLasso(){\n      const svg = d3.select('#div_graph').select(\"svg\")\n      var circles_question = svg.selectAll('.outline')\n      let that = this\n      var lasso_start = function () {\n        console.log(111)\n        lasso.items()\n          .attr('fill', \"green\")\n          .classed('not_possible', true)\n          .classed('selected', false)\n      }\n      var lasso_draw = function () {\n        // Style the possible dots\n        lasso.possibleItems()\n          .classed('not_possible', false)\n          .classed('possible', true)\n\n        // Style the not possible dot\n        lasso.notPossibleItems()\n          .classed('not_possible', true)\n          .classed('possible', false)\n      }\n      var lasso_end = function () {\n        lasso.items()\n          .classed('not_possible', false)\n          .classed('possible', false)\n\n        lasso.selectedItems()\n          .classed('selected', true)\n        that.selectedEntities.splice(0, that.selectedEntities.length)\n        that.selectedRelations.splice(0, that.selectedRelations.length) \n        lasso.selectedItems().each(function(d){\n          const label = this.nodeName \n          \n          if (label == \"circle\") {\n            console.log(\"adding entity\" + d.id)\n            that.selectedEntities.push(d.id)\n          }else {\n            console.log(\"adding Relations\" + d.id)\n            that.selectedRelations.push(d.id)\n          }\n          \n        })\n        // Reset the style of the not selected dots\n        // lasso.notSelectedItems()\n        \n      }\n      var lasso = d3Lasso.lasso()\n        .closePathSelect(true)\n        .closePathDistance(100)\n        .items(circles_question)\n        .targetArea(svg)\n        .on('start', lasso_start)\n        .on('draw', lasso_draw)\n        .on('end', lasso_end)\n\n      svg.call(lasso)\n    }, \n    disableLasso() {\n      const svg = d3.select('#div_graph').select(\"svg\") \n      svg.on(\".dragstart\", null);\n      svg.on(\".drag\", null);\n      svg.on(\".dragend\", null);\n    }, \n    enableZoomPan(){\n      const svg = d3.select('#div_graph').select(\"svg\") \n      svg.call(d3.zoom().on('zoom', function () {\n        var scale = d3.event.transform.k,\n          translate = [d3.event.transform.x, d3.event.transform.y]\n        console.log(1)\n        const g = svg.select(\"g\")\n        g.attr('transform', 'translate(' + translate[0] + ', ' + translate[1] + ') scale(' + scale + ')')\n      }))\n      .on('dblclick.zoom', null)\n    },\n    disableZoom() {\n      const svg = d3.select('#div_graph').select(\"svg\") \n      svg.on('.zoom', null)\n    },\n    toggleOverviewPanel(focus){\n      if (focus == \"entity\") {\n        const containerFocus = document.querySelector(\"#div_node_overview\")\n        const containerUnFocus = document.querySelector(\"#div_link_overview\")\n        containerFocus.style.border = \"2px solid green\"\n        containerUnFocus.style.border = \"None\"\n      } else{\n        const containerFocus = document.querySelector(\"#div_link_overview\")\n        const containerUnFocus = document.querySelector(\"#div_node_overview\")\n        containerFocus.style.border = \"2px solid green\"\n        containerUnFocus.style.border = \"None\"\n      }\n    },\n    retrieve_types_nodes(){\n      this.$store.dispatch(\"retrieveNodesLinksWithTypes\", this.brushed)\n    },\n    // circleUpdateMatchColor(){\n    //   if (this.colorMapping) {\n    //     Object.keys(this.colorMapping).forEach(category => {\n    //       d3.selectAll('.'+category).style('fill', this.colorMapping[category])\n    //     })\n    //   }\n    // },\n    recolorNode(){\n      var that = this\n      d3.select('#div_graph').selectAll('circle').style('fill',function(d){\n      // check cold chain data\n        if('resilience' in d['properties']){\n          console.log(d['properties'])\n          if(d['properties']['resilience']>=that.resilience_thre){\n            if(that.selectedColor){\n              return that.selectedColor.hex\n            }else{\n              return \"#78b3d0\"\n            }\n            \n          }else{\n            return \"#b3b3b3\"\n          }\n        }\n      })\n    }\n  },\n  watch: {\n    fixed() {\n      if (this.fixed) {\n        // componentDisableDragHandler(\n        //   `.globalview-canvas-${this.itemProps.id}`,\n        //   this.toolStatus\n        // );\n        this.enableZoomPan()\n      } else {\n        this.disableZoom()\n      }\n    },\n    selectedColor() {\n      this.recolorNode()\n      // d3.selectAll('circle').style('fill', this.selectedColor.hex)\n    },\n    resilience_thre(){\n      this.recolorNode()\n    },\n    'itemProps.graphData'() {\n      var all_resilience = []\n      this.itemProps.graphData['results'][0]['data'][0]['graph']['nodes'].forEach(function (d) {\n        d['status'] = 'unclicked'\n        // check if this is cold chain data or not \n        if(\"resilience\" in d['properties']){\n          all_resilience.push(parseFloat(d['properties']['resilience']))\n        }\n        \n      })\n      // this.min_resilience = d3.min(all_resilience)\n      this.max_resilience = d3.max(all_resilience)\n      console.log(this.max_resilience)\n      //inital the selected resilience\n      KGutils.graphDataParsing(this.itemProps.graphData, this.currentEntities, this.currentRelations)\n      this.drawNeo4jd3()\n      // this.circleUpdateMatchColor()\n    }, \n    selectedEntities(val) {\n      if (val.length > 0) {\n        console.log(\"retrieving data now!!!\")\n        console.log(val.length)\n        console.log(this.selectedEntities)\n        console.log(this.selectedRelations)\n        console.log(\"****************\")\n        console.log(val)\n        this.$store.dispatch(\"retrieveSubTable\", {entities: this.selectedEntities, relations: this.selectedRelations})\n        this.$store.dispatch(\"retrieveNodeGeo\", {node: this.selectedEntities})\n      }\n    }, \n    selectedRelations(val){\n      if (val.length > 0) {\n        console.log(\"****************\")\n        console.log(val.length)\n        console.log(val) \n        console.log(\"retrieving data now!!!\")\n        console.log(this.selectedEntities)\n        console.log(this.selectedRelations)\n        this.$store.dispatch(\"retrieveSubTable\", {entities: this.selectedEntities, relations: this.selectedRelations})\n      }\n    }, \n    brushed:{\n      handler(val){\n          console.log(val);\n      },\n      deep:true \n    },\n    'itemProps.relationStatusReady': function (val){\n      console.log(\"relation status: \" + val) \n    },\n    'itemProps.relationTypeData':function(val) {\n      if(this.itemProps.relationStatusReady) {\n        console.log(\"relation type data is ready\")\n\n      }else{\n        console.log(\"relation type data is not ready yet!\")\n      }\n    },\n    'itemProps.loading': function(val){\n      this.loading_value = val\n    },\n    \n  },\n  computed: {\n    getBorder() {\n      return this.FIXED ? \"2px solid grey\" : \"None\";\n    },\n    // HEIGHT () {\n    //   return window.innerHeight*0.7 + 'px'\n    // },\n    // OVERVIEW_HEIGHT(){\n    //   return window.innerHeight*0.3 + 'px'\n    // }\n  }\n}\n</script>\n<style scoped>\n\n.lasso path {\n    stroke: rgb(80,80,80);\n    stroke-width:2px;\n}\n\n.lasso .drawn {\n    fill-opacity:.05 ;\n}\n\n.lasso .loop_close {\n    fill:none;\n    stroke-dasharray: 4,4;\n}\n\n.lasso .origin {\n    fill:#3399FF;\n    fill-opacity:.5;\n}\n\n.not_possible {\n    fill: rgb(200,200,200);\n}\n\n.possible {\n    fill: #EC888C;\n}\n\n.nodes .selected {\n    fill: green!important;\n    stroke-width: 3px!important;\n    stroke: black;\n}\n.relationships .selected {\n    stroke-width: 5px !important;\n    stroke: green!important;\n}\n.graph-btn-container{\n    position: relative; \n    top: 5px;\n}\n.kg-view-btn{\n  margin-right: 10px;\n}\n\n.circle-button:hover{\n  cursor: pointer;\n}\n\n.card-name {\n    text-align: center;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    flex-wrap: wrap;\n    height: 100%;\n  }\n\n.card-inner{\n  text-align: center;\n  align-items: center;\n  justify-content: center;\n  flex-wrap: wrap;\n  height: 100%;\n}\n</style>\n"]}]}